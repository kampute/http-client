<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Kampute.HttpClient | Kampute.HttpClient </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Kampute.HttpClient | Kampute.HttpClient ">
    
    
      <link rel="shortcut icon" href="favicon.ico">
      <link rel="stylesheet" href="styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="styles/docfx.css">
      <link rel="stylesheet" href="styles/main.css">
      <meta property="docfx:navrel" content="">
      <meta property="docfx:tocrel" content="">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><a href="https://github.com/kampute/http-client/actions/workflows/main.yml"><img src="https://github.com/kampute/http-client/actions/workflows/main.yml/badge.svg?branch=master" alt="Build, Test, and Document"></a></p>
<h1 id="kamputehttpclient">Kampute.HttpClient</h1>
<p><code>Kampute.HttpClient</code> is a .NET library designed to simplify HTTP communication with RESTful APIs by enhancing the native <code>HttpClient</code> capabilities.
Tailored for developers seeking a potent yet flexible HTTP client for API integration within .NET applications, it combines ease of use with a wide
array of functionalities to address the complexities of web service consumption.</p>
<h2 id="key-features">Key Features</h2>
<ul>
<li><p><strong>Shared HttpClient Instances:</strong>
Facilitates the reuse of a single <code>HttpClient</code> instance across multiple <code>HttpRestClient</code> instances, promoting efficient resource and connection
management. This approach significantly boosts performance in scenarios involving concurrent access to multiple services or API endpoints.</p>
</li>
<li><p><strong>Flexible HttpClient Configuration:</strong>
Allows the integration of custom or shared <code>HttpClient</code> instances, complete with configurations for message handlers, timeouts, and advanced authentication
mechanisms to fit specific application needs.</p>
</li>
<li><p><strong>Custom Error Handling and Exception Management:</strong>
Converts HTTP response errors into detailed, meaningful exceptions, streamlining the process of interpreting API-specific errors with the aid of a customizable
error response type set through the <code>ResponseErrorType</code> property. Furthermore, it enhances flexibility in error management with the <code>ErrorHandlers</code> collection,
allowing for response status code-specific handling. Developers can craft and utilize custom <code>IHttpErrorHandler</code> implementations to address distinct HTTP errors
directly, facilitating the development of refined retry strategies and precise error responses tailored to specific needs.</p>
</li>
<li><p><strong>Retry Strategies with Backoff Mechanisms:</strong>
Implements backoff strategies to handle transient failures and network interruptions effectively. These strategies, configurable via the <code>BackoffStrategy</code>
property, ensure resilient communication by dictating the logic for retrying requests, thereby preventing server overload and optimizing resource use.</p>
</li>
<li><p><strong>Modular Content Processing:</strong>
Supports extendable serialization/deserialization modules for seamless integration with common and custom content types. It uses a collection of response
deserializers that automatically convert HTTP response content into .NET objects based on the response's <code>Content-Type</code>, and proactively informs the service
of the content types it is configured to accept by setting the appropriate <code>Accept</code> headers. This dual-functionality simplifies the process of working with
API responses and ensures seamless data integration by aligning expected response formats with the client’s capabilities.</p>
</li>
<li><p><strong>Streamlined Authentication and Authorization:</strong>
Simplifies the process of integrating various authentication schemes and dynamic reauthorization, facilitating straightforward implementation of authentication
strategies.</p>
</li>
<li><p><strong>Request and Response Interception:</strong>
Provides events such as <code>BeforeSendingRequest</code> and <code>AfterReceivingResponse</code> for executing custom logic before sending a request or after receiving a response.
This feature enables detailed request modification, response inspection, and logging, offering developers full control over the HTTP communication process.</p>
</li>
<li><p><strong>Asynchronous API for Enhanced Performance:</strong>
Promotes fully asynchronous network operations with support for cancellation tokens, ensuring efficient management of long-running requests in line with modern
asynchronous programming practices in .NET.</p>
</li>
</ul>
<h2 id="serialization-support">Serialization Support:</h2>
<p>By default, <code>Kampute.HttpClient</code> does not include any content deserializer. To accommodate popular content types, the following extension packages are available:</p>
<ul>
<li><p><strong><a href="https://www.nuget.org/packages/Kampute.HttpClient.Json">Kampute.HttpClient.Json</a></strong>:
Utilizes the <code>System.Text.Json</code> library for handling JSON content types, offering high-performance serialization and deserialization that integrates tightly
with the .NET ecosystem.</p>
</li>
<li><p><strong><a href="https://www.nuget.org/packages/Kampute.HttpClient.NewtonsoftJson">Kampute.HttpClient.NewtonsoftJson</a></strong>:
Leverages the <code>Newtonsoft.Json</code> library for handling JSON content types, providing extensive customization options and compatibility with a vast number of JSON
features and formats.</p>
</li>
<li><p><strong><a href="https://www.nuget.org/packages/Kampute.HttpClient.Xml">Kampute.HttpClient.Xml</a></strong>:
Employs the <code>XmlSerializer</code> for handling XML content types, enabling straightforward serialization and deserialization of XML into .NET objects using custom
class structures.</p>
</li>
<li><p><strong><a href="https://www.nuget.org/packages/Kampute.HttpClient.DataContract">Kampute.HttpClient.DataContract</a></strong>:
Utilizes the <code>DataContractSerializer</code> for handling XML content types, focusing on serialization and deserialization of .NET objects into XML based on data contract
attributes for fine-grained control over the XML output.</p>
</li>
</ul>
<p>For scenarios where the provided serialization packages do not meet specific requirements, <code>Kampute.HttpClient</code> allows the implementation of custom deserializers.
Developers can create their own serialization modules by implementing interfaces for deserialization, thus enabling support for custom content types or proprietary
data formats.</p>
<h2 id="installation">Installation</h2>
<p>Install <code>Kampute.HttpClient</code> via NuGet:</p>
<pre><code class="lang-shell">dotnet add package Kampute.HttpClient
</code></pre>
<h2 id="usage-examples">Usage Examples</h2>
<p>The examples below demonstrate how to use the library for common tasks.</p>
<h3 id="basic-usage">Basic Usage</h3>
<p>To get started with <code>HttpRestClient</code>, simply instantiate it and use it to perform HTTP requests.</p>
<pre><code class="lang-csharp">using Kampute.HttpClient;
using Kampute.HttpClient.Json;

// Create a new instance of the HttpRestClient
using var client = new HttpRestClient();

// Configure the client to accept JSON responses, using System.Text.Json library.
// This is an extension method provided by the Kampute.HttpClient.Json package.
client.AcceptJson();

// Perform a GET request.
// The GetAsync&lt;TResponse&gt; method will automatically deserialize the JSON response
// into the specified MyModel type.
var data = await client.GetAsync&lt;MyModel&gt;(&quot;https://api.example.com/resource&quot;);
</code></pre>
<h3 id="custom-retry-strategies">Custom Retry Strategies</h3>
<p>The library offers various retry strategies to manage transient failures, ensuring your application remains resilient during network instability or temporary
service unavailability. The example below demonstrates how to apply a Fibonacci backoff strategy, which gradually increases the delay between retries, balancing
the need to retry soon against the need to wait longer as the number of attempts increases.</p>
<pre><code class="lang-csharp">using Kampute.HttpClient;

// Create a new instance of the HttpRestClient
using var client = new HttpRestClient();

// Configure the client's retry mechanism.
// The Fibonacci strategy will retry up to 5 times 
// with an initial delay of 1 second between retries
// and delay increases following the Fibonacci sequence for subsequent retries.
client.BackoffStrategy = BackoffStrategies.Fibonacci(maxAttempts: 5, initialDelay: TimeSpan.FromSeconds(1));
</code></pre>
<h3 id="handling-http-errors">Handling HTTP Errors</h3>
<p>The library includes built-in handlers for managing common HTTP errors, streamlining the implementation of custom logic for error responses.
Here's how to utilize the built-in '401 Unauthorized' error handler:</p>
<pre><code class="lang-csharp">using Kampute.HttpClient;
using Kampute.HttpClient.ErrorHandlers;

// Create an instance of the built-in '401 Unauthorized' error handler.
// This handler defines the logic to handle unauthorized responses.
using var unauthorizedErrorHandler = new HttpError401Handler(async (client, challenges, cancellationToken) =&gt;
{
    // In this example, we're handling the unauthorized error by making a POST request to an 
    // authentication endpoint to obtain a new authentication token.
    var auth = await client.PostAsFormAsync&lt;AuthToken&gt;(&quot;https://api.example.com/auth&quot;,
    [
        KeyValuePair.Create(&quot;client_id&quot;, MY_APP_ID),
        KeyValuePair.Create(&quot;client_secret&quot;, MY_APP_SECRET)
    ]);

    // Return a new AuthenticationHeaderValue with the obtained token.
    // This will be used to include the authentication header in subsequent requests.
    return new AuthenticationHeaderValue(AuthSchemes.Bearer, auth.Token);
});

// Create a new instance of the HttpRestClient
using var client = new HttpRestClient();

// Register the unauthorized error handler with the client.
// This allows the client to handle '401 Unauthorized' responses automatically.
client.ErrorHandlers.Add(unauthorizedErrorHandler);
</code></pre>
<p>Additionally, handling '503 Service Unavailable' and '429 Too Many Requests' errors is simplified with the built-in handler, ensuring your application can gracefully
retry requests during service outages and rate limit encounters.</p>
<h3 id="handling-content-types">Handling Content Types</h3>
<p>For handling specific content types like JSON or XML, consider using the available extension packages.</p>
<p>In the example below, we assume that both the <code>Kampute.HttpClient.NewtonsoftJson</code> package, which facilitates JSON content handling through the <code>Newtonsoft.Json</code>
library, and the <code>Kampute.HttpClient.DataContract</code> package, enabling XML content management via <code>DataContractSerializer</code>, have been installed.</p>
<pre><code class="lang-csharp">using Kampute.HttpClient;
using Kampute.HttpClient.NewtonsoftJson;
using Kampute.HttpClient.DataContract;

// Create a new instance of the HttpRestClient.
using var client = new HttpRestClient();

// Configure the client to accept JSON responses, using the Newtonsoft.Json library.
// This is an extension method provided by the Kampute.HttpClient.NewtonsoftJson package
client.AcceptJson();

// Configure the client to accept XML responses, using DataContractSerializer.
// This is an extension method provided by the Kampute.HttpClient.DataContract package
client.AcceptXml();

// Execute a GET request. The server may respond in either JSON or XML format.
// The GetAsync&lt;TResponse&gt; method will automatically deserialize the response
// into the specified MyResource type, based on the response content type (JSON or XML).
var result = await client.GetAsync&lt;MyResource&gt;(&quot;https://api.example.com/resource&quot;);

// Send a PATCH request with a payload in JSON format.
// The PatchAsJsonAsync method is provided by the Kampute.HttpClient.NewtonsoftJson package.
await client.PatchAsJsonAsync(&quot;https://api.example.com/resource&quot;, new { name = &quot;new name&quot; });

// Send a POST request with a payload in XML format.
// The PostAsXmlAsync method is provided by the Kampute.HttpClient.DataContract package.
var newResource = new MyResource();
await client.PostAsXmlAsync(&quot;https://api.example.com/resource&quot;, newResource);
</code></pre>
<h2 id="contributing">Contributing</h2>
<p>Contributions are welcomed! Please feel free to fork the repository, make changes, and submit pull requests. For major changes or new features, please open an issue
first to discuss what you would like to change.</p>
<h2 id="license">License</h2>
<p><code>Kampute.HttpClient</code> is licensed under the terms of the MIT license. See the <a href="LICENSE">LICENSE</a> file for more details.</p>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/kampute/http-client/blob/master/README.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      © 2024 Kampute
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
